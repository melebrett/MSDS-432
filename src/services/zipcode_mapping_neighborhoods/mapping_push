package main

import (
	"database/sql"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"

	"github.com/joho/godotenv"
	_ "github.com/joho/godotenv/autoload"

	//"github.com/kelvins/geocoder"
	_ "github.com/lib/pq"
)

type Neighborhoods struct {
	LATITUDE     float64 `json:"latitude"`
	LONGITUDE    float64 `json:"longitude"`
	PRI_NEIGH    string  `json:"pri_neigh"`
	SEC_NEIGH    string  `json:"sec_neigh"`
	SHAPE_AREA   string  `json:"shape_area"`
	SHAPE_LEN    string  `json:"shape_len"`
	ASSIGNED_ZIP string  `json:"assigned_zip"`
}

type Nominatim struct {
	PlaceId     int              `json:"place_id"`
	Category    string           `json:"category"`
	DisplayName string           `json:"display_name"`
	Address     NominatimAddress `json:"address"`
	Boundingbox []string         `json:"boundingbox"`
}

type NominatimAddress struct {
	HomeNumber    int    `json:"house_number"`
	Road          string `json:"road"`
	Neighbourhood string `json:"neighbourhood"`
	Suburb        string `json:"suburb"`
	City          string `json:"city"`
	Municipality  string `json:"municipality"`
	County        string `json:"county"`
	Postcode      string `json:"postcode"`
}

var Hoods []Neighborhoods
var HoodZips []Neighborhoods

func query_neighs() []Neighborhoods {
	db, err := DLConnect()
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	statement := `SELECT LATITUDE, LONGITUDE, PRI_NEIGH, SEC_NEIGH, SHAPE_AREA, SHAPE_LEN FROM neighborhoods n
					WHERE SEC_NEIGH = 'BRONZEVILLE' LIMIT 10`

	rows, err := db.Query(statement)
	if err != nil {
		log.Fatal("Error querying database: ", err)
	}

	Data := []Neighborhoods{}

	for rows.Next() {
		var latitude float64
		var longitude float64
		var pri_neigh string
		var sec_neigh string
		var shape_area string
		var shape_len string
		err = rows.Scan(&latitude, &longitude, &pri_neigh, &sec_neigh, &shape_area, &shape_len)
		if err != nil {
			log.Fatal("Scan error", err)
		}
		temp := Neighborhoods{LATITUDE: latitude, LONGITUDE: longitude, PRI_NEIGH: pri_neigh, SEC_NEIGH: sec_neigh, SHAPE_AREA: shape_area, SHAPE_LEN: shape_len}

		Data = append(Data, temp)
	}

	defer rows.Close()

	return Data
}

func GetNeighborhoodZip(userAgent string, lat, lon float64) string {
	var myresults Nominatim
	url := fmt.Sprintf("https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=%f&lon=%f", lat, lon)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
	}
	req.Header.Set("User-Agent", userAgent)
	client := &http.Client{}
	resp, err := client.Do(req)

	if err != nil {
		fmt.Println(err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		fmt.Println(resp.StatusCode)
	}

	resBody, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		fmt.Println(err)
	}

	json.Unmarshal(resBody, &myresults)

	return myresults.DisplayName
}

func GetZipCode(userAgent string, lat, lon float64) string {
	var myresults Nominatim
	url := fmt.Sprintf("https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=%f&lon=%f", lat, lon)
	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		fmt.Println(err)
	}

	req.Header.Set("User-Agent", userAgent)

	client := &http.Client{}

	resp, err := client.Do(req)

	if err != nil {
		fmt.Println(err)
	}

	defer resp.Body.Close()

	if resp.StatusCode != 200 {

		fmt.Println(resp.StatusCode)

	}

	resBody, err := ioutil.ReadAll(resp.Body)

	if err != nil {

		fmt.Println(err)

	}

	json.Unmarshal(resBody, &myresults)

	fmt.Println(myresults)

	return myresults.Address.Postcode
}

// data lake connection
func DLConnect() (*sql.DB, error) {
	//Retreiving DB connection credential environment variables
	err := godotenv.Load("dbconn.env")
	var DLHOST = os.Getenv("DLHOST")
	var DLPORT = os.Getenv("DLPORT")
	var DLUSER = os.Getenv("DLUSER")
	var DLPASSWORD = os.Getenv("DLPASSWORD")
	var DLDBNAME = os.Getenv("DLDBNAME")
	if err != nil {
		log.Println("Could not load .env file", err)
	}

	DB_DSN := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", DLHOST, DLPORT, DLUSER, DLPASSWORD, DLDBNAME)

	db, err := sql.Open("postgres", DB_DSN)

	if err != nil {
		return nil, err
	}

	log.Println("Successfully connected to Data Lake")

	return db, nil
}

// data mart connection
func DMConnect() (*sql.DB, error) {
	//Retreiving DB connection credential environment variables
	err := godotenv.Load("dbconn.env")
	var DMHOST = os.Getenv("DMHOST")
	var DMPORT = os.Getenv("DMPORT")
	var DMUSER = os.Getenv("DMUSER")
	var DMPASSWORD = os.Getenv("DMPASSWORD")
	var DMDBNAME = os.Getenv("DMDBNAME")
	if err != nil {
		log.Println("Could not load .env file")
	}

	DB_DSN := fmt.Sprintf("host=%s port=%s user=%s password=%s dbname=%s sslmode=disable", DMHOST, DMPORT, DMUSER, DMPASSWORD, DMDBNAME)

	db, err := sql.Open("postgres", DB_DSN)

	if err != nil {
		return nil, err
	}

	log.Println("Successfully connected to Data Mart")

	return db, nil
}

func CreateDataLakeTable() {
	db, err := DLConnect()
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	dropTableStatement := "DROP TABLE IF EXISTS neighborhood_zips_temp;"

	_, err = db.Exec(dropTableStatement)
	if err != nil {
		panic(err)
	}

	createTableStatement := `CREATE TABLE neighborhood_zips_temp (
								ZIPCODE         TEXT,
								LATITUDE        FLOAT,
								LONGITUDE   	FLOAT,
								PRI_NEIGH       TEXT,
								SEC_NEIGH      	TEXT
							);`

	_, err = db.Exec(createTableStatement)
	if err != nil {
		panic(err)
	}
}

func CreateDataMartTable() {
	db, err := DMConnect()
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	dropTableStatement := "DROP TABLE IF EXISTS neighborhood_zips;"

	_, err = db.Exec(dropTableStatement)
	if err != nil {
		panic(err)
	}

	createSecondTableStatement := `CREATE TABLE neighborhood_zips (
									ZIPCODE        TEXT,
									PRI_NEIGH      TEXT,
									SEC_NEIGH      TEXT
								);`
	_, err = db.Exec(createSecondTableStatement)
	if err != nil {
		panic(err)
	}

	insertStatement := `insert into neighborhood_zips
						select zipcode, pri_neigh, sec_neigh
						from (select zipcode, pri_neigh, sec_neigh, 
									rank() over (partition by pri_neigh, sec_neigh order by numzips desc) rankno
							from (
								select zipcode, pri_neigh, sec_neigh, count(*)numzips
								from neighborhood_zips_temp
								group by zipcode, pri_neigh, sec_neigh))
						where rankno = 1;`
	_, err = db.Exec(insertStatement)
	if err != nil {
		panic(err)
	}

}

func DropDataLakeTable() {
	db, err := DLConnect()
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	dropTableStatement := "DROP TABLE IF EXISTS neighborhood_zips_temp;"

	_, err = db.Exec(dropTableStatement)
	if err != nil {
		panic(err)
	}
}

func LoadToDataLake(neighborhoodList []Neighborhoods) {
	db, err := DLConnect()
	if err != nil {
		log.Fatal(err)
	}

	defer db.Close()

	insertStatementLake := `INSERT INTO neighborhood_zips_temp (Zipcode, Latitude, Longitude, PRI_NEIGH, SEC_NEIGH)
										values ($1, $2, $3, $4, $5)`

	for _, v := range neighborhoodList {
		_, err = db.Exec(insertStatementLake, v.ASSIGNED_ZIP, v.LATITUDE, v.LONGITUDE, v.PRI_NEIGH, v.SEC_NEIGH)
		if err != nil {
			log.Println("Error inserting record, PRI_NEIGH = ", v.PRI_NEIGH, err)
		}
	}
}

func main() {
	Hoods = query_neighs()
	//fmt.Println(Hoods)

	for i := 0; i < len(Hoods); i++ {
		record := &Hoods[i]

		zip := GetZipCode("msds432-final-group-4", record.LATITUDE, record.LONGITUDE)
		record.ASSIGNED_ZIP = zip

	}
	//fmt.Println(HoodZips)
	//CreateDataLakeTable()
	//LoadToDataLake(Hoods)
	//CreateDataMartTable()
	//DropDataLakeTable()

}
